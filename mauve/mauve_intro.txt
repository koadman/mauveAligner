Alignment of DNA sequences determines identical nucleotides in two or more sequences.  Alignment highlights the differences between sequences, providing a basis for comparative inference in genetics.  Recent advances in DNA sequencing technology have fueled the determination of genome sequences for many organisms.  Aligning several genome sequences presents problems not posed when aligning short collinear sequences.  Recombination causes frequent genome rearrangements that require new methods of identification and special handling that are not necessary when aligning short collinear sequences. Horizontal transfer introduces new sequences into chromosomes and deletions remove segments of the genome. Consequently, each genome is a mosaic of unique lineage specific segments, regions shared with a subset of other genomes and segments conserved among all the genomes under consideration. Further, the linear order of these segments can be shuffled among genomes. 

We present a method and software package called Mauve that has been developed to simultaneously align several genomes.  Successful multiple genome alignment promises to provide great insights for comparative genomics but has thus far proven to be a daunting task.  Mauve is the first system capable of aligning multiple genomes containing inversions, rearrangements, and lineage specific regions.  The resulting alignments yield a vast amount of information about the organisms under study.  In addition to SNPs and indels identified by traditional gene to gene alignments, Mauve identifies regions conserved in all organisms, regions common to subsets of the organisms, regions of lineage specific sequence, inversions, and the breakpoints of genomic rearrangements.  

Such information provides a basis for further study of the rates and patterns of horizontal transfer events, inversions,  rearrangements, and other recombinational phenomena.  


The information provided by multiple genome alignments will form the foundation for further research in genomic science.  

\section{Previous Work}

Sequence alignment has been an active research field for over 30 years.
Initial research studied techniques for aligning pairs of short collinear sequences.  Since then, methods have been developed to align multiple short collinear sequences~\cite{clustalw,chaos,others}, pairs of genome sequences~\cite{mummer,mummer2,glass,avid,others}, and most recently, multiple collinear genome sequences~\cite{mga,mlagan}.  Because so many approaches to sequence alignment have been developed, we limit our discussion to previous methods most relevant to Mauve.

Methods for aligning pairs of short collinear sequences were developed in response to availability of gene sequences.  Two well known methods are the Smith-Waterman local alignment algorithm and the Needleman-Wunsch global alignment algorithm.  Both methods rely on the calculation of a dynamic programming matrix.  In their simplest form, these methods require O(n^2) space and running time to find the highest scoring alignment between two sequences of length n.

Smith-Waterman and Needleman-Wunsch can be generalized to align multiple sequences, however the running time is O(n^m) where n is again the length of the sequences and m is the number of sequences being aligned.  Because O(n^m) is too costly for all but the shortest sequences, heuristic methods to approximate the highest scoring alignment were developed.  ClustalW is one such method.  In ClustalW, each of the O(m^2) pairs of sequences are aligned using Smith-Waterman and the resulting alignments are used to build a phylogenetic tree for the sequences.  ClustalW generates a multiple alignment by first aligning the closest two sequences in the phylogenetic tree.  The 3rd through m_th sequences are then aligned to the existing alignment in an order determined by their phylogenetic distance from the current set of aligned sequences. 

\subsection{Genome Alignment}
The dependence of ClustalW and related alignment methods on an O(n^2) pairwise alignment algorithm prevents them from being applied to long genome sequences.  Several heuristic methods to align pairs of genomes have been developed recently.  These methods have a common aspect in that they quickly find long regions of similarity between the sequences called anchors.  Because the anchors are very likely to be part of the final alignment, they can be used to restrict the search space to a small subset of the O(n^2) possible alignments.  Pairwise genome aligners vary in the methods they use for locating anchors and completing the anchored alignment.

MUMmer and MUMmer2 use a suffix tree to locate anchors in O(n) time.  In MUMmer each anchor is a maximal unique match (MUM).  A MUM is an exactly matching region containing a subsequence unique in each genome that can not be extended to a larger region without including a mismatch.  To complete an anchored alignment, MUMmer selects a collinear set of MUMs using the longest increasing subsequence algorithm in O(n log n) time and then uses Smith-Waterman to align the intervening regions between anchors.  While MUMmer can find MUMs in the reverse complement orientation, its selection of a collinear set of MUMs prevents it from completely aligning genomes with significant rearrangements.
GLASS locates exactly matching anchors of some minimum length using a hashing algorithm.  It then recursively searches the intervening regions between anchors for smaller exact matches to use as anchors.  FIXME something happens next
LAGAN is a pairwise genome aligner that relaxes the assumption of exactly matching anchors used by MUMmer and GLASS.  LAGAN uses the CHAOS alignment algorithm to locate anchors and selects a collinear set of anchors in a manner similar to MUMmer.  The anchors in LAGAN are used to guide a dynamic programming algorithm to finish the alignment.  Unlike other anchored alignment methods, the final LAGAN alignment does not necessarily include the anchors themselves but the alignment path must pass within some fixed distance of the anchors in the dynamic programming matrix.  The ability to use inexact anchors and the flexibility of their incorporation into the final alignment permit LAGAN to align more distantly related genomes than other methods, however the selection of a collinear set of anchors limits LAGAN to genomes without inversions or rearrangements.

\subsection{Multiple Genome Alignment}
The availability of related genome sequences has also fueled research into methods for multiple genome alignment.  MGA is one such multiple genome alignment system.  MGA uses virtual suffix trees to locate multiMEMs, maximal length exact matches that occur in all sequences being aligned.  MGA then selects a maximum weight collinear chain of multiMEMs to anchor further alignment.  A recursive anchor search using a smaller minimum anchor size is performed on the intervening regions between anchors.  MGA finishes the alignment by invoking ClustalW on each intervening region.  Because the multiMEM anchors must contain a matching region in every sequence being aligned, MGA can not align significant regions shared by subsets of the sequences being aligned.  Also, its reliance on a maximum weight collinear chain of anchors prevents MGA from aligning significant rearrangements and inversions.

MLAGAN is an extension of LAGAN designed to align multiple genomes.  MLAGAN utilizes a user-specified phylogenetic guide tree to progressively align each genome to the existing alignment.  The MLAGAN approach can align sequences with significant subset match regions, but assumes collinear sequences.

The assumption of collinear sequence is a common problem in all anchored alignment techniques.  Pevzner and Tesler recently reported a method for determining the collinear regions in two sequences using a set of anchors, however their method has not yet been integrated into an pairwise genome alignment system.  

\section{Methods}
We have developed a theoretical framework and algorithms to simultaneously identify and align significant collinear regions in multiple genomes.  Like other genome aligners, Mauve first locates a set of anchors to base its alignment.  Next, Mauve partitions the anchors into collinear regions called Locally Collinear Blocks (LCBs) and performs further alignment on each LCB.  Some LCBs may correspond to small regions of sequence that are very unlikely to represent true genomic rearrangements.  Mauve uses a heuristic approach to identify and remove these insignificant LCBs.  Figure~\ref{fig:algorithm} shows a flowchart detailing the algorithm.


\subsection{Finding Anchors}
The type of anchor used in genome alignment can impact the quality of the alignment.~\cite{avid}  Exactly matching anchors are less sensitive than inexact anchors.  Mauve uses maximal unique matches (MUMs) of some minimum length k to anchor its alignments.  As in MUMmer, a MUM represents an exactly matching region between two or more sequences that can not be extended without including a mismatch.  By using MUMs, Mauve can identify anchors shared by all sequences or a subset of sequences and anchors that include inverted regions of sequence.  Mauve attempts to compensate for the lower sensitivity of MUMs by performing recursive alignment with a reduced value for k, the minimum MUM size.  

MUMs are identified using a simple seed and extend style hashing algorithm.  First Mauve constructs a data structure called a sorted mer list (SML) for each sequence being aligned.  An SML is a vector <p_0,..,p_n> of sequence positions corresponding to each of the n mers of length k in a circular genome of length n.  This vector of sequence positions is sorted using the mers as a sort key.  An SML can simultaneously represent the forward and reverse complement strands by using the lexicographically lesser of the forward and reverse complement mers at each position.  Figure~\ref{fig:sml} illustrates sorted mer list construction.

Once a sorted mer list has been constructed for each of the m sequences, Mauve scans the m SMLs simultaneously looking for exact and unique matches between two or more sequences.  Each exact and unique match is a MUM seed that will be extended if it is not part of a MUM that has already been found.  When a mismatch is encountered during seed extension, a new MUM is seeded and checked for each subset of sequences that continue to match.

MUMs are denoted by the tuple <l,s_0,..,s_m> where l is the length of the MUM and s_i represents the left end coordinate of the MUM in the i_th sequence.  MUMs that do not match in sequence i have a value of 0 for s_i.  A match in sequence i in the reverse complement orientation is denoted by using the negative value of left end coordinate.  MUM seeds are checked against a hash table of tuples representing known MUMs to decide wether the seed should be extended.  

Constructing an SML takes O(n) time using radix sort, seed extension can consume O(m^2*n) time, and a loose upper bound for checking wether a seed is part of an existing MUM is O(m*n log n).  Thus, an upper bound for the time complexity of finding anchors is O( m^2*n log n ).

\subsection{Identifying Locally Collinear Blocks}

In the case of collinear sequences an alignment can be completed by simply selecting an optimal collinear chain of anchors and aligning the intervening regions between these anchors.  However in sequences and genomes containing significant rearrangements and inversions, the relative ordering of anchors will differ in each sequence.  Spurious matches and repetitive regions may also result in different relative ordering of anchors.  To complete an alignment of non-collinear sequences, significant regions of collinear anchors must be distinguished from the spurious anchors that suggest unlikely rearrangements.  Figure~\ref{fig:rearrangement_blocks} depicts a set of anchors containing significant rearrangements and spurious matches.  Each collinear region, represented by a disjoint subset of the anchors, is referred to as a Locally Collinear Block (LCB).  An LCB may contain regions homologous in all sequences, regions shared by a subset of the sequences, and lineage specific sequence, but does not contain any rearrangements of homologous sequence.

We have developed a method to identify collinear regions of anchors and remove spurious anchors.  Our method is composed of two fundamental steps.  First, collinear subsets of anchors are identified using a novel graph theoretical framework we call an interval adjacency graph.  Next, collinear subsets of anchors corresponding to unlikely LCBs are repeatedly removed until all remaining LCBs meet the user specified likelihood criteria.

\subsection{The Interval Adjacency Graph}
The interval adjacency graph is a connected digraph G C <v,e> containing vertices V and directed edges E that represents the adjacencies of anchors in each sequence.  Each node in the graph corresponds to an anchor, and nodes for adjacent anchors are connected by directed edges labeled with the sequence(s) in which the anchors are adjacent.  Edges are oriented to connect anchors from left to right based on their location in the sequence.  Edges connecting inverted regions require special handling as they must connect anchors from right to left.  For example, the forward oriented anchor to the left of a region of inverted anchors connects to the right-most anchor of the inverted region.  Similarly, the left-most anchor of the inverted region connects to the forward anchor immediately to the right of the inverted region.

The path represented by an in-order traversal of all edges with a particular sequence label corresponds to the order anchors occur in that sequence.  Figure~\ref{fig:rearrangement_graph} gives an example interval adjacency graph for the set of anchors depicted in Figure~\ref{fig:rearrangement_blocks}.



 it is necessary to evaluate the quality 

By using unique matches and recursive alignment Mauve avoids the combinatorial nightmare caused by many repetitive regions occurring in each